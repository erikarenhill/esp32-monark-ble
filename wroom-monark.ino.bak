#include <Arduino.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// ------------------ LCD ------------------
// If blank, try 0x3F instead of 0x27
LiquidCrystal_I2C lcd(0x27, 16, 2);

// ------------------ Pins (ESP32) ------------------
static const int PIN_CADENCE = 27;   // reed switch input
static const int PIN_POT_ADC = 34;   // ADC1 input-only pin (good for BLE later)

// I2C pins on ESP32 (common defaults)
static const int PIN_I2C_SDA = 21;
static const int PIN_I2C_SCL = 22;

// ------------------ Cadence tuning ------------------
static const uint32_t EDGE_DEBOUNCE_MS   = 12;
static const uint32_t MIN_REV_PERIOD_MS  = 200;
static const uint32_t WINDOW_MS          = 3000;   // 3s smoothing
static const uint32_t TIMEOUT_MS         = 5000;
static const uint32_t REPORT_MS          = 1000;

// ------------------ ADC ------------------
static const uint8_t ADC_SAMPLES = 32;

// ------------------ Monark power model ------------------
static float cycle_constant = 1.05f;   // 1.00 brake wheel, 1.05 crank (default)

// ------------------ Calibration (kp) ------------------
// NOTE: These were your ESP8266 values. ESP32 ADC counts WILL differ.
// Use this sketch to read ADC at 0/2/4/6 kp and update these.
static int ADC_0KP = 78;
static int ADC_2KP = 125;
static int ADC_4KP = 177;
static int ADC_6KP = 226;

// ------------------ Timestamp buffer ------------------
static const uint8_t TS_BUF_SIZE = 32;
volatile uint32_t ts_buf[TS_BUF_SIZE];
volatile uint8_t  ts_head = 0;
volatile uint8_t  ts_count = 0;

// Debug / state
volatile uint32_t edges_total = 0;
volatile uint32_t edges_accepted = 0;
volatile uint32_t last_edge_ms = 0;
volatile uint32_t last_rev_ms = 0;
volatile bool armed_for_count = true;

// Snapshot for safe reading
struct Snapshot {
  uint32_t ts[TS_BUF_SIZE];
  uint8_t count;
  uint32_t last_rev;
  uint32_t et, ea;
};

// ------------------ Helpers ------------------
static void lcdPrintFixed(uint8_t col, uint8_t row, const char* text) {
  lcd.setCursor(col, row);
  lcd.print(text);
  int len = strlen(text);
  for (int i = len; i < (16 - col); i++) lcd.print(' ');
}

static inline void push_timestamp(uint32_t t_ms) {
  ts_buf[ts_head] = t_ms;
  ts_head = (ts_head + 1) % TS_BUF_SIZE;
  if (ts_count < TS_BUF_SIZE) ts_count++;
}

static inline float lerp(float x, float x0, float y0, float x1, float y1) {
  if (x1 == x0) return y0;
  float t = (x - x0) / (x1 - x0);
  return y0 + t * (y1 - y0);
}

static float adc_to_kp(int adc) {
  // clamp
  if (adc <= ADC_0KP) return 0.0f;
  if (adc >= ADC_6KP) return 6.0f;

  if (adc <= ADC_2KP) {
    return lerp(adc, ADC_0KP, 0.0f, ADC_2KP, 2.0f);
  } else if (adc <= ADC_4KP) {
    return lerp(adc, ADC_2KP, 2.0f, ADC_4KP, 4.0f);
  } else {
    return lerp(adc, ADC_4KP, 4.0f, ADC_6KP, 6.0f);
  }
}

// ------------------ Cadence ISR ------------------
void IRAM_ATTR cadenceISR() {
  uint32_t now = millis();
  edges_total++;

  if ((now - last_edge_ms) < EDGE_DEBOUNCE_MS) return;
  last_edge_ms = now;
  edges_accepted++;

  bool isClosed = (digitalRead(PIN_CADENCE) == LOW);

  if (!isClosed) {
    armed_for_count = true;
    return;
  }

  if (!armed_for_count) return;
  armed_for_count = false;

  if (last_rev_ms != 0 && (now - last_rev_ms) < MIN_REV_PERIOD_MS) return;

  last_rev_ms = now;
  push_timestamp(now);
}



static Snapshot snapshotState() {
  Snapshot s{};
  noInterrupts();

  s.count = ts_count;
  uint8_t head = ts_head;
  for (uint8_t i = 0; i < ts_count; i++) {
    uint8_t idx = (head + TS_BUF_SIZE - ts_count + i) % TS_BUF_SIZE;
    s.ts[i] = ts_buf[idx];
  }

  s.last_rev = last_rev_ms;
  s.et = edges_total;
  s.ea = edges_accepted;

  interrupts();
  return s;
}

static float rpm_from_window(const uint32_t* ts, uint8_t count) {
  if (count < 2) return 0.0f;

  uint32_t newest = ts[count - 1];
  uint8_t first = 0;
  while (first < count && (newest - ts[first]) > WINDOW_MS) first++;

  uint8_t n = count - first;
  if (n < 2) return 0.0f;

  uint32_t dt = newest - ts[first];
  if (dt == 0) return 0.0f;

  return (float)(n - 1) * 60000.0f / (float)dt;
}

static int readAdcAvg(uint8_t samples) {
  uint32_t sum = 0;
  for (uint8_t i = 0; i < samples; i++) {
    sum += analogRead(PIN_POT_ADC);
    delay(2);
  }
  return (int)(sum / samples);
}

void setup() {
  Serial.begin(115200);
  delay(200);

  // ADC setup (ESP32): set attenuation for 0-3.3V-ish range
  // This affects counts; we'll recalibrate anyway.
  analogSetPinAttenuation(PIN_POT_ADC, ADC_11db);

  pinMode(PIN_CADENCE, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(PIN_CADENCE), cadenceISR, CHANGE);

  Wire.begin(PIN_I2C_SDA, PIN_I2C_SCL);
  lcd.begin(16, 2);
  lcd.backlight();
  lcd.clear();

  lcdPrintFixed(0, 0, "ESP32 LT2 test");
  lcdPrintFixed(0, 1, "No BLE yet");

  Serial.println();
  Serial.println("=== ESP32 LT2 test (no BLE) ===");
  Serial.println("Pins: cadence=GPIO27 (to GND), pot=A0(GPIO34), I2C SDA=21 SCL=22");
  Serial.printf("Cycle constant: %.2f\n", cycle_constant);
  Serial.printf("Calib ADC (TEMP): 0/2/4/6 kp = %d %d %d %d\n", ADC_0KP, ADC_2KP, ADC_4KP, ADC_6KP);
  Serial.println("TIP: capture new ESP32 ADC values for 0/2/4/6 kp and update constants.");
}

void loop() {
  static uint32_t last_report = 0;
  uint32_t now = millis();

  if ((now - last_report) >= REPORT_MS) {
    last_report = now;

    Snapshot s = snapshotState();
    float rpm = rpm_from_window(s.ts, s.count);

    if (s.last_rev && (now - s.last_rev) > TIMEOUT_MS) rpm = 0.0f;

    int adc = readAdcAvg(ADC_SAMPLES);
    float kp = adc_to_kp(adc);

    float power_brake = kp * rpm;
    float power_out = power_brake * cycle_constant;

    Serial.printf("rpm=%.1f adc=%d kp=%.2f | P_brake=%.1f P_out=%.1f C=%.2f | edges=%lu acc=%lu\n",
                  rpm, adc, kp, power_brake, power_out, cycle_constant,
                  (unsigned long)s.et, (unsigned long)s.ea);

    char line1[17], line2[17];
    snprintf(line1, sizeof(line1), "P:%4.0fW C:%3.0f", power_out, rpm);
    snprintf(line2, sizeof(line2), "kp:%1.2f A:%4d", kp, adc);

    lcdPrintFixed(0, 0, line1);
    lcdPrintFixed(0, 1, line2);
  }

  delay(1);
}
